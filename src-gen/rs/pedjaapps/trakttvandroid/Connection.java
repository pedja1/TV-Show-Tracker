package rs.pedjaapps.trakttvandroid;

import java.util.List;
import rs.pedjaapps.trakttvandroid.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table connection.
 */
public class Connection {

    private Long id;
    /** Not-null value. */
    private String name;
    private Boolean connected;
    private Boolean timeline_enabled;
    private Boolean share_scrobblers_start;
    private Boolean share_scrobblers_end;
    private Boolean share_tv;
    private Boolean share_movies;
    private Boolean share_ratings;
    private Boolean share_checkins;
    private long userId;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient ConnectionDao myDao;

    private List<User> userList;

    public Connection() {
    }

    public Connection(Long id) {
        this.id = id;
    }

    public Connection(Long id, String name, Boolean connected, Boolean timeline_enabled, Boolean share_scrobblers_start, Boolean share_scrobblers_end, Boolean share_tv, Boolean share_movies, Boolean share_ratings, Boolean share_checkins, long userId) {
        this.id = id;
        this.name = name;
        this.connected = connected;
        this.timeline_enabled = timeline_enabled;
        this.share_scrobblers_start = share_scrobblers_start;
        this.share_scrobblers_end = share_scrobblers_end;
        this.share_tv = share_tv;
        this.share_movies = share_movies;
        this.share_ratings = share_ratings;
        this.share_checkins = share_checkins;
        this.userId = userId;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getConnectionDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    /** Not-null value. */
    public String getName() {
        return name;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setName(String name) {
        this.name = name;
    }

    public Boolean getConnected() {
        return connected;
    }

    public void setConnected(Boolean connected) {
        this.connected = connected;
    }

    public Boolean getTimeline_enabled() {
        return timeline_enabled;
    }

    public void setTimeline_enabled(Boolean timeline_enabled) {
        this.timeline_enabled = timeline_enabled;
    }

    public Boolean getShare_scrobblers_start() {
        return share_scrobblers_start;
    }

    public void setShare_scrobblers_start(Boolean share_scrobblers_start) {
        this.share_scrobblers_start = share_scrobblers_start;
    }

    public Boolean getShare_scrobblers_end() {
        return share_scrobblers_end;
    }

    public void setShare_scrobblers_end(Boolean share_scrobblers_end) {
        this.share_scrobblers_end = share_scrobblers_end;
    }

    public Boolean getShare_tv() {
        return share_tv;
    }

    public void setShare_tv(Boolean share_tv) {
        this.share_tv = share_tv;
    }

    public Boolean getShare_movies() {
        return share_movies;
    }

    public void setShare_movies(Boolean share_movies) {
        this.share_movies = share_movies;
    }

    public Boolean getShare_ratings() {
        return share_ratings;
    }

    public void setShare_ratings(Boolean share_ratings) {
        this.share_ratings = share_ratings;
    }

    public Boolean getShare_checkins() {
        return share_checkins;
    }

    public void setShare_checkins(Boolean share_checkins) {
        this.share_checkins = share_checkins;
    }

    public long getUserId() {
        return userId;
    }

    public void setUserId(long userId) {
        this.userId = userId;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<User> getUserList() {
        if (userList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            UserDao targetDao = daoSession.getUserDao();
            List<User> userListNew = targetDao._queryConnection_UserList(id);
            synchronized (this) {
                if(userList == null) {
                    userList = userListNew;
                }
            }
        }
        return userList;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetUserList() {
        userList = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
